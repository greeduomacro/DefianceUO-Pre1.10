using System;
using System.Collections;
using System.Xml.Serialization;
using System.IO;
using System.Reflection;

using Server;
using Server.Mobiles;
using Server.Items;

namespace Arya.DialogEditor
{
	/// <summary>
	/// Summary description for DialogNPC.
	/// </summary>
	public class DialogNPC : BaseCreature
	{
		/// <summary>
		/// This is the folder where the XML configuration files are stored.
		/// This path is considered based at the RunUO folder.
		/// </summary>
		private static string m_XmlFolder = @"TheBox\Dialog";

		#region Variables

		/// <summary>
		/// The configuration object for this NPC
		/// </summary>
		private DialogEditor.Dialog m_Dialog;
		/// <summary>
		/// The list of players that are currently viewing a gump generated by this NPC
		/// </summary>
		private ArrayList m_Users;
		/// <summary>
		/// The location of the configuration file used by this NPC
		/// </summary>
		private string m_FileName = null;
		/// <summary>
		/// Specifies whether the NPC will react to players or not
		/// </summary>
		private bool m_Active = false;
		/// <summary>
		/// Specifies if the current configuration needs to handle speech
		/// </summary>
		private bool m_HandleSpeech;
		/// <summary>
		/// Specifies if the current configuration needs to handle double clicks
		/// </summary>
		private bool m_HandleDblClick;
		/// <summary>
		/// Specifies if the current configuration needs to handle items given
		/// </summary>
		private bool m_HandleItemGiven;
		/// <summary>
		/// Specifies if the current configuration needs to handle items in backpack
		/// </summary>
		private bool m_HandleItem;

		#endregion

		#region Properties

		[ CommandProperty( AccessLevel.GameMaster ) ]
		/// <summary>
		/// States whether the NPC is active and can react to players
		/// </summary>
		public bool Active
		{
			get { return m_Active; }
			set
			{
				m_Active = value && m_Dialog != null && m_Dialog.Init.Count > 0;
			}
		}

		[ CommandProperty( AccessLevel.GameMaster ) ]
		/// <summary>
		/// Gets the name of the XML file used to currently configure the NPC
		/// </summary>
		public string DialogName
		{
			get
			{
				if ( m_FileName == null || ! File.Exists( m_FileName ) )
					return "None";
				else
					return Path.GetFileNameWithoutExtension( m_FileName );
			}
			set
			{
				if ( value == null )
				{
					SetFileName( null, null );
				}
				else
				{
					string dir = Path.Combine( Core.BaseDirectory, m_XmlFolder );
					string file = Path.Combine( dir, string.Format( "{0}.xml", value ) );
					SetFileName( file, null );
				}
			}
		}

		/// <summary>
		/// Gets the list of all configuration files available for a DialogNPC
		/// </summary>
		public static string[] ConfigurationFiles
		{
			get
			{
				string directory = Path.Combine( Core.BaseDirectory, m_XmlFolder );

				if ( ! Directory.Exists( directory ) )
					return null;

				return Directory.GetFiles( directory, "*.xml" );
			}
		}

		#endregion

		[ Constructable ]
		public DialogNPC() : base( AIType.AI_Thief, FightMode.None, 10, 1, 0.8, 1.6 )
		{
			m_Users = new ArrayList();
			EventSink.Disconnected += new DisconnectedEventHandler(OnPlayerDisconnected);

			CantWalk = true;
			Hidden = true;

			InitStats( 100, 25, 100 );

			Blessed = true;
			RangeHome = 5;

			InitOutfit();
			InitProps();
		}

		#region Outfit

		private void InitOutfit()
		{
			ArrayList items = new ArrayList( Items );

			foreach( Item item in items )
				item.Delete();

			Items.Clear();

			if ( m_Dialog == null )
			{
				Name = "Unconfigured Dialog NPC";
				Title = null;
				Body = 0x190;
				Hue = 0;
				return;
			}

			if ( m_Dialog.Outfit.CustomOutfit )
				InitCustomOutfit();
			else
				InitDefaultOutfit();

			// Call custom function
			if ( m_Dialog.Outfit.CustomFunction )
			{
				Type t = FindType( m_Dialog.Outfit.FunctionType );

				if ( t != null )
				{
					MethodInfo method = t.GetMethod( m_Dialog.Outfit.Function );

					if ( method != null )
					{
						try
						{
							method.Invoke( null, new object[] { this } );
						}
						catch {}
					}
				}
			}
		}

		private void InitCustomOutfit()
		{
			Outfit fit = m_Dialog.Outfit;

			Blessed = fit.Blessed;

			if ( fit.Creature )
			{
				BodyValue = fit.Body;
			}
			else
			{
				BodyValue = fit.Female ? 0x191 : 0x190;
			}

			Hue = fit.Hue;
			Name = fit.Name;
			Title = fit.Title;

			if ( ! fit.Creature )
			{
				switch ( fit.Hair )
				{
					case "Afro" : AddItem( new Afro( fit.HairHue ) );
						break;

					case "Buns" : AddItem( new BunsHair( fit.HairHue ) );
						break;

					case "Krisna" : AddItem( new KrisnaHair( fit.HairHue ) );
						break;

					case "Long" : AddItem( new LongHair( fit.HairHue ) );
						break;

					case "Mohawk" : AddItem( new Mohawk( fit.HairHue ) );
						break;

					case "Pageboy" : AddItem( new PageboyHair( fit.HairHue ) );
						break;

					case "Pony Tail" : AddItem( new PonyTail( fit.HairHue ) );
						break;

					case "Receeding" : AddItem( new ReceedingHair( fit.HairHue ) );
						break;

					case "Short" : AddItem( new ShortHair( fit.HairHue ) );
						break;

					case "Two Pig Tails" : AddItem( new TwoPigTails( fit.HairHue ) );
						break;
				}

				switch( fit.Beard )
				{
					case "Goatee" : AddItem( new Goatee( fit.HairHue ) );
						break;

					case "Long" : AddItem( new LongBeard( fit.HairHue ) );
						break;

					case "Medium Long" : AddItem( new MediumLongBeard( fit.HairHue ) );
						break;

					case "Medium Short" : AddItem( new MediumShortBeard( fit.HairHue ) );
						break;

					case "Short" : AddItem( new ShortBeard( fit.HairHue ) );
						break;
				}

				if ( fit.Mustache )
					AddItem( new Mustache( fit.MustacheHue ) );
			}

			foreach ( ItemEntry entry in fit.Items )
			{
				Item item = entry.Item;

				if ( item != null )
					AddItem( item );
			}

			InitStats( fit.Str, fit.Dex, fit.Int );

			for ( int i = 0; i < 52; i++ )
			{
				SetSkill( ( SkillName ) i, fit.Skills[ i ] );
			}
		}

		private void InitDefaultOutfit()
		{
			if ( Female == Utility.RandomBool() )
			{
				// Female
				Name = NameList.RandomName( "female" );
				Body = 0x191;
			}
			else
			{
				Name = NameList.RandomName( "male" );
				Body = 0x190;
			}

			Title = null;

			switch ( Utility.Random( 3 ) )
			{
				case 0: AddItem( new FancyShirt( GetRandomHue() ) ); break;
				case 1: AddItem( new Doublet( GetRandomHue() ) ); break;
				case 2: AddItem( new Shirt( GetRandomHue() ) ); break;
			}

			switch ( ShoeType )
			{
				case VendorShoeType.Shoes: AddItem( new Shoes( GetShoeHue() ) ); break;
				case VendorShoeType.Boots: AddItem( new Boots( GetShoeHue() ) ); break;
				case VendorShoeType.Sandals: AddItem( new Sandals( GetShoeHue() ) ); break;
				case VendorShoeType.ThighBoots: AddItem( new ThighBoots( GetShoeHue() ) ); break;
			}

			int hairHue = Utility.RandomHairHue();

			if ( Female )
			{
				switch ( Utility.Random( 6 ) )
				{
					case 0: AddItem( new ShortPants( GetRandomHue() ) ); break;
					case 1:
					case 2: AddItem( new Kilt( GetRandomHue() ) ); break;
					case 3:
					case 4:
					case 5: AddItem( new Skirt( GetRandomHue() ) ); break;
				}

				switch ( Utility.Random( 9 ) )
				{
					case 0: AddItem( new Afro( hairHue ) ); break;
					case 1: AddItem( new KrisnaHair( hairHue ) ); break;
					case 2: AddItem( new PageboyHair( hairHue ) ); break;
					case 3: AddItem( new PonyTail( hairHue ) ); break;
					case 4: AddItem( new ReceedingHair( hairHue ) ); break;
					case 5: AddItem( new TwoPigTails( hairHue ) ); break;
					case 6: AddItem( new ShortHair( hairHue ) ); break;
					case 7: AddItem( new LongHair( hairHue ) ); break;
					case 8: AddItem( new BunsHair( hairHue ) ); break;
				}
			}
			else
			{
				switch ( Utility.Random( 2 ) )
				{
					case 0: AddItem( new LongPants( GetRandomHue() ) ); break;
					case 1: AddItem( new ShortPants( GetRandomHue() ) ); break;
				}

				switch ( Utility.Random( 8 ) )
				{
					case 0: AddItem( new Afro( hairHue ) ); break;
					case 1: AddItem( new KrisnaHair( hairHue ) ); break;
					case 2: AddItem( new PageboyHair( hairHue ) ); break;
					case 3: AddItem( new PonyTail( hairHue ) ); break;
					case 4: AddItem( new ReceedingHair( hairHue ) ); break;
					case 5: AddItem( new TwoPigTails( hairHue ) ); break;
					case 6: AddItem( new ShortHair( hairHue ) ); break;
					case 7: AddItem( new LongHair( hairHue ) ); break;
				}

				switch ( Utility.Random( 5 ) )
				{
					case 0: AddItem( new LongBeard( hairHue ) ); break;
					case 1: AddItem( new MediumLongBeard( hairHue ) ); break;
					case 2: AddItem( new Vandyke( hairHue ) ); break;
					case 3: AddItem( new Mustache( hairHue ) ); break;
					case 4: AddItem( new Goatee( hairHue ) ); break;
				}
			}
		}

		private int GetRandomHue()
		{
			switch ( Utility.Random( 5 ) )
			{
				default:
				case 0: return Utility.RandomBlueHue();
				case 1: return Utility.RandomGreenHue();
				case 2: return Utility.RandomRedHue();
				case 3: return Utility.RandomYellowHue();
				case 4: return Utility.RandomNeutralHue();
			}
		}

		private int GetShoeHue()
		{
			if ( 0.1 > Utility.RandomDouble() )
				return 0;

			return Utility.RandomNeutralHue();
		}

		private VendorShoeType ShoeType
		{
			get{ return VendorShoeType.Shoes; }
		}

		#endregion

		#region Properties Initialization

		/// <summary>
		/// Initializes the properties defined by the props settings
		/// </summary>
		private void InitProps()
		{
			ClearProps();

			if ( m_Dialog == null )
				return;

			try
			{
				NPCProps p = m_Dialog.Props;

				FightMode = (FightMode) Enum.Parse( typeof( FightMode ), p.FightMode, false );
				AI = (AIType) Enum.Parse( typeof( AIType ), string.Format( "AI_{0}", p.AI, false ) );

				Fame = p.Fame;
				Karma = p.Karma;

				if ( IsValidValue( p.Hits ) )
				{
					if ( IsSingleValue( p.Hits ) )
						SetHits( GetValue( p.Hits ) );
					else
						SetHits( GetValues( p.Hits )[ 0 ], GetValues( p.Hits )[ 1 ] );
				}

				if ( IsValidValue( p.Stam ) )
				{
					if ( IsSingleValue( p.Stam ) )
						SetStam( GetValue( p.Stam ) );
					else
						SetStam( GetValues( p.Stam )[ 0 ], GetValues( p.Stam )[ 1 ] );
				}

				if ( IsValidValue( p.Mana ) )
				{
					if ( IsSingleValue( p.Mana ) )
						SetMana( GetValue( p.Mana ) );
					else
						SetMana( GetValues( p.Mana )[ 0 ], GetValues( p.Mana )[ 1 ] );
				}

				if ( IsValidValue( p.Damage ) )
				{
					if ( IsSingleValue( p.Damage ) )
						SetDamage( GetValue( p.Damage ) );
					else
						SetDamage( GetValues( p.Damage )[ 0 ], GetValues( p.Damage )[ 1 ] );
				}

				for ( int i = 0; i < 5; i++ )
				{
					string d = p.Damages[ i ];
					string r = p.Resistances[ i ];

					if ( IsValidValue( d ) )
					{
						if ( IsSingleValue( d ) )
							SetDamageType( (ResistanceType) i, GetValue( d ) );
						else
							SetDamageType( (ResistanceType) i, GetValues( d )[ 0 ], GetValues( d )[ 1 ] );
					}

					if ( IsValidValue( r ) )
					{
						if ( IsSingleValue( r ) )
							SetResistance( (ResistanceType) i, GetValue( r ) );
						else
							SetResistance( (ResistanceType) i, GetValues( r )[ 0 ], GetValues( r )[ 1 ] );
					}
				}

				if ( p.Mount != null && p.Mount.Length > 0 )
				{
					try
					{
						Type t = FindType( p.Mount );

						if ( t != null )
						{
							object obj = Activator.CreateInstance( t );

							IMount mount = obj as IMount;

							if ( mount != null )
							{
								( mount as Mobile ).Hue = p.MountHue;
								mount.Rider = this;
							}
							else
							{
								Mobile m = obj as Mobile;
								Item i = obj as Item;

								if ( m != null )
									m.Delete();

								if ( i != null )
									i.Delete();
							}
						}
					}
					catch {}

					for ( int i = 0; i < p.Properties.Count; i++ )
					{
						try
						{
							string prop = p.Properties[ i ] as string;
							string val = p.Values[ i ] as string;

							PropertyInfo pinfo = GetType().GetProperty( prop );

							if ( pinfo != null )
							{
								Server.Scripts.Commands.Properties.InternalSetValue( null, null, this, pinfo, pinfo.Name, val, false );
							}
						}
						catch {}
					}
				}
			}
			catch ( Exception err )
			{
				Console.WriteLine( "An error occurred when configuring a DialogNPC with the {0} datafile", DialogName );
				Console.WriteLine( err.ToString() );
			}
		}

		private bool IsValidValue( string val )
		{
			if ( val == null || val == string.Empty )
				return false;

			int v = 0;
			int[] vs = null;

			try
			{
				if ( IsSingleValue( val ) )
					v = GetValue( val );
				else
					vs = GetValues( val );
			}
			catch
			{
				return false;
			}

			return true;
		}

		private bool IsSingleValue( string val )
		{
			return val.IndexOf( "," ) == -1;
		}

		private int GetValue( string val )
		{
			val = val.Replace( " ", "" );
			return int.Parse( val );
		}

		private int[] GetValues( string val )
		{
			val = val.Replace( " ", "" );
			string[] vals = val.Split( ',' );

			int[] v = new int[ 2 ];
			v[ 0 ] = int.Parse( vals[ 0 ] );
			v[ 1 ] = int.Parse( vals[ 1 ] );

			return v;
		}

		/// <summary>
		/// Resets all the properties set on the NPC
		/// </summary>
		private void ClearProps()
		{
			SetHits( 1 );
			SetStam( 1 );
			SetMana( 1 );
			Fame = 0;
			Karma = 0;

			SetDamage( 0 );

			for ( int i = 0; i < 5; i++ )
			{
				SetDamageType( (ResistanceType) i, 0 );
				SetResistance( (ResistanceType) i, 0 );
			}

			if ( Mount != null )
			{
				( Mount as Mobile ).Delete();
			}
		}

		#endregion

		#region Serialization

		public DialogNPC( Serial serial ) : base( serial )
		{
			m_Users = new ArrayList();
		}

		public override void Serialize(GenericWriter writer)
		{
			base.Serialize (writer);

			writer.Write( 0 ); // Version

			writer.Write( m_FileName );
			writer.Write( m_Active );
		}

		public override void Deserialize(GenericReader reader)
		{
			base.Deserialize (reader);

			int version = reader.ReadInt();

			m_FileName = reader.ReadString();
			m_Active = reader.ReadBool();

			Configure( null );

			EventSink.Disconnected += new DisconnectedEventHandler(OnPlayerDisconnected);
		}

		#endregion

		/// <summary>
		/// When player disconnects, remove it from the current users
		/// </summary>
		private void OnPlayerDisconnected(DisconnectedEventArgs e)
		{
			if ( m_Users.Contains( e.Mobile ) )
				m_Users.Remove( e.Mobile );
		}

		/// <summary>
		/// Finds a type through its name
		/// </summary>
		/// <param name="name">The type name</param>
		/// <returns>A Type is a match is found, null if none</returns>
		public static Type FindType( string name )
		{
			Type t = ScriptCompiler.FindTypeByName( name, true );

			if ( t != null )
				return t;

			t = ScriptCompiler.FindTypeByFullName( name, true );

			return t;
		}

		#region Configuration

		/// <summary>
		/// Sets the filename used to configure the NPC
		/// </summary>
		/// <param name="file">The filename - set to null to clear NPC</param>
		/// <param name="m">The mobile configuring the NPC</param>
		public void SetFileName( string file, Mobile m )
		{
			m_FileName = file;

			Configure( m );

			if ( m_FileName == null )
			{
				m_Dialog = null;
				m_Active = false;
				m_Users.Clear();
			}
		}

		/// <summary>
		/// Configures the NPC with the selected file
		/// </summary>
		/// <param name="m">The mobile configuring the NPC. This can be null.</param>
		private void Configure( Mobile m )
		{
			if ( m_FileName == null || ! File.Exists( m_FileName ) )
			{
				m_FileName = null;
				return;
			}

			m_Dialog = Dialog.Load( m_FileName );

			if ( m_Dialog == null && m != null )
			{
				SendMessage( 0x40, "The selected file is not a valid configuration." );
			}

			m_Active = true;

			CalculateReactions();
			InitOutfit();
			InitProps();
		}

		/// <summary>
		/// Reads all dialog inits and sets flags so that the NPC knows what events not to handle
		/// </summary>
		private void CalculateReactions()
		{
			m_HandleItem = false;
			m_HandleItemGiven = false;
			m_HandleDblClick = false;
			m_HandleSpeech = false;

			if ( m_Dialog == null )
				return;

			foreach( DialogInit init in m_Dialog.Init )
			{
				m_HandleSpeech |= ( init.ReactToKeywords && init.Keywords.Length > 0 );
				m_HandleDblClick |= init.ReactToDoubleClick;
				m_HandleItem |= ( init.ReactToItemInBackpack && init.TypeBackpack != null && init.TypeBackpack.Length > 0 );
				m_HandleItemGiven |= ( init.ReactToItemGiven && init.TypeGiven != null && init.TypeGiven.Length > 0 );
			}

			Hidden = ! Active;
			CantWalk = ! Active;
		}

		#endregion

		#region Handlers for NPC reactions

		public override bool HandlesOnSpeech(Mobile from)
		{
			if ( ! m_HandleSpeech || m_Dialog == null || !Active )
				return false;

			if ( m_Users.Contains( from ) )
				return false;

			if ( ! from.CheckAlive( false ) )
				return false;

			return from.InRange( this.Location, m_Dialog.SpeechRange );
		}

		public override void OnSpeech(SpeechEventArgs e)
		{
			if ( m_Dialog == null )
				return;

			DialogInit match = null;

			foreach( DialogInit init in m_Dialog.Init )
			{
				if ( init.ReactToKeywords )
				{
					foreach( string key in init.Keywords )
					{
						if ( e.Speech.IndexOf( key ) > -1 )
						{
							match = init;
							break;
						}
					}

					if ( match != null )
						break;
				}
			}

			if ( match != null && match.DoFunctionTrigger( this, e.Mobile ) )
			{
				e.Handled = true;
				StartConversation( e.Mobile, match );
			}
		}

		public override bool OnDragDrop(Mobile from, Item dropped)
		{
			if ( m_Dialog == null || ! m_HandleItemGiven || ! Active || m_Users.Contains( from ) )
			{
				this.SayTo( from, "*shakes head*" );
				return false;
			}

			DialogInit match = null;

			foreach( DialogInit init in m_Dialog.Init )
			{
				if ( init.ReactToItemGiven && init.ItemGivenType != null )
				{
					if ( dropped.GetType() == init.ItemGivenType && dropped.Amount >= init.AmountGiven )
					{
						match = init;
						break;
					}
				}
			}

			if ( match != null && match.DoFunctionTrigger( this, from ) )
			{
				StartConversation( from, match );

				// If dropped more than needed, just take what's required
				if ( dropped.Amount > match.AmountGiven )
				{
					dropped.Amount -= match.AmountGiven;
					return false;
				}
				else
				{
					return true;
				}
			}
			else
			{
				this.SayTo( from, "*shakes head*" );
				return false;
			}
		}

		public override void OnMovement(Mobile m, Point3D oldLocation)
		{
			if ( !m.Player || m_Dialog == null || ! m_HandleItem || ! Active || m_Users.Contains( m ) || !m.CheckAlive( false ) )
			{
				base.OnMovement( m, oldLocation );
				return;
			}

			// Trigger only when entering the range region: oldLocation not in range and new location in range

			if ( ! ( this.InRange( m.Location, m_Dialog.Range ) && ! this.InRange( oldLocation, m_Dialog.Range ) ) )
			{
				base.OnMovement( m, oldLocation );
				return;
			}

			DialogInit match = null;

			foreach( DialogInit init in m_Dialog.Init )
			{
				if ( init.ReactToItemInBackpack && init.ItemType != null && m.Backpack != null )
				{
					Item target = m.Backpack.FindItemByType( init.ItemType, true );

					if ( target != null )
					{
						if ( target.Amount >= init.AmountBackpack )
						{
							match = init;
							break;
						}
					}
				}
			}

			if ( match != null && match.DoFunctionTrigger( this, m ) )
			{
				StartConversation( m, match );
			}
			else
			{
				base.OnMovement (m, oldLocation);
			}
		}

		public override void OnDoubleClick(Mobile from)
		{
			if ( from.AccessLevel >= AccessLevel.GameMaster )
			{
				from.SendGump( new FileSelectionGump( this, from ) );
			}

			if ( !m_HandleDblClick || m_Dialog == null || !Active || m_Users.Contains( from ) || ! from.CheckAlive( false ) )
				return;

			DialogInit match = null;

			foreach( DialogInit init in m_Dialog.Init )
			{
				if ( init.ReactToDoubleClick )
				{
					match = init;
					break;
				}
			}

			if ( match != null && match.DoFunctionTrigger( this, from ) )
			{
				StartConversation( from, match );
			}
		}

		#endregion

		#region Gump Logic

		/// <summary>
		/// This function verifies if there is still a valid dialog. Staff might re-configure the NPC while a player might be using it.
		/// </summary>
		/// <param name="m">The mobile that is using the NPC</param>
		/// <returns>True if the NPC is still functional, False otherwise</returns>
		private bool Verify( Mobile m )
		{
			if ( m_Dialog == null )
			{
				m.SendMessage( 0x40, "This NPC is no longer functional. Please try again later." );
			}

			return m_Dialog != null;
		}

		/// <summary>
		/// Verifies if a speech is valid. This because some might used un-verified configurations.
		/// </summary>
		/// <param name="m">The mobile using the NPC</param>
		/// <param name="speech">The speech object being checked</param>
		/// <returns>True if the speech exists, false if it's null</returns>
		private bool VerifySpeech( Mobile m, DialogSpeech speech )
		{
			if ( speech == null )
			{
				m.SendMessage( 0x40, "The script for this NPC is incorrect. Please contact a Game Master and inform that the script '{0}' is bugged.", DialogName );
			}

			return speech != null;
		}

		/// <summary>
		/// Begins a conversation with a player by sending them the first gump
		/// </summary>
		/// <param name="m">The mobile beginning the conversation</param>
		/// <param name="init">The DialogInit object specifying the starting condition</param>
		private void StartConversation( Mobile m, DialogInit init )
		{
			if ( ! Verify( m ) )
				return;

			DialogSpeech speech = m_Dialog.GetSpeech( init.Speech );

			if ( ! VerifySpeech( m, speech ) )
				return;

			m_Users.Add( m );

			SendSpeechGump( speech, m );
		}

		/// <summary>
		/// Performs a choice after it's been selected by a user
		/// </summary>
		/// <param name="m">The user of the conversation</param>
		/// <param name="choice">The choice selected through the gump</param>
		public void PerformChoice( Mobile m, DialogChoice choice )
		{
			if ( ! Verify( m ) )
				return;

			if ( choice.Invoke )
			{
				choice.PerformInvoke( m, this );
			}

			if ( choice.EndDialog )
			{
				m_Users.Remove( m );
				return;
			}

			DialogSpeech speech = m_Dialog.GetSpeech( choice.ChoiceID );

			if ( ! VerifySpeech( m, speech ) )
			{
				m_Users.Remove( m );
				return;
			}

			SendSpeechGump( speech, m );
		}

		/// <summary>
		/// Sends the actual speech gump
		/// </summary>
		/// <param name="speech">The speech object being displayed</param>
		/// <param name="m">The player receiving the gump</param>
		private void SendSpeechGump( DialogSpeech speech, Mobile m )
		{
			ArrayList choices = new ArrayList();

			foreach( Guid id in speech.Choices )
			{
				DialogChoice c = m_Dialog.GetChoice( id );

				if ( c != null )
					choices.Add( c );
			}

			m.SendGump( new ConversationGump( m_Dialog, speech, choices, this, m ) );
		}

		/// <summary>
		/// Sends the specified player the speech identified by the specified ID.
		/// This function will do nothing if the ID isn't valid for this Dialog, and should be only called
		/// from external functions
		/// </summary>
		/// <param name="guid">The string representation of the unique GUID of the speech that should be displayed</param>
		/// <param name="m">The Mobile who should receive the speech</param>
		public void RunSpeechGump( string guid, Mobile m )
		{
			try
			{
				Guid id = new Guid( guid );
				RunSpeechGump( id, m );
			}
			catch{}
		}

		/// <summary>
		/// Sends the specified player the speech identified by the specified ID.
		/// This function will do nothing if the ID isn't valid for this Dialog, and should be only called
		/// from external functions
		/// </summary>
		/// <param name="guid">The unique GUID of the speech that should be displayed</param>
		/// <param name="m">The Mobile who should receive the speech</param>
		public void RunSpeechGump( Guid guid, Mobile m )
		{
			if ( ! Verify( m ) )
				return;

			DialogSpeech speech = m_Dialog.GetSpeech( guid );

			if ( ! VerifySpeech( m, speech ) )
				return;

			SendSpeechGump( speech, m );
		}

		/// <summary>
		/// This function ends the conversation when the user chooses the End Conversation button on the gump
		/// </summary>
		/// <param name="m">The user closing the conversation</param>
		public void EndConversation( Mobile m )
		{
			if ( m_Users.Contains( m ) )
				m_Users.Remove( m );
		}

		#endregion
	}
}